<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Flink相关 | Blog</title><meta name="description" content="Flink相关"><meta name="keywords" content="大数据,Flink"><meta name="author" content="Fibonacci"><meta name="copyright" content="Fibonacci"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://sovwcwsfm.com/blog/page/flink"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Flink相关"><meta name="twitter:description" content="Flink相关"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="Flink相关"><meta property="og:url" content="http://sovwcwsfm.com/blog/page/flink"><meta property="og:site_name" content="Blog"><meta property="og:description" content="Flink相关"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="MySQL" href="http://sovwcwsfm.com/blog/page/MySQL20210615.html"><link rel="next" title="Flume相关" href="http://sovwcwsfm.com/blog/page/flume.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.sovwcwsfm.com","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Flink"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Flink</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">简介</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Flink"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">为什么用Flink</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E7%89%B9%E6%80%A7"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">特性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%A4%84%E7%90%86%E6%9C%89%E7%95%8C%E5%92%8C%E6%97%A0%E7%95%8C%E6%95%B0%E6%8D%AE"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">处理有界和无界数据</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E8%BF%90%E8%A1%8C%E8%8C%83%E5%9B%B4%E5%B9%BF"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">运行范围广</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E8%BF%90%E8%A1%8C%E4%BB%BB%E6%84%8F%E8%A7%84%E6%A8%A1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">运行任意规模的应用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%88%A9%E7%94%A8%E5%86%85%E5%AD%98%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">利用内存提升性能</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%AD%96%E7%95%A5"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">数据传输策略</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#forward-strategy"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">forward strategy</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#key-based-strategy-key-by"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">key based strategy (key by)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#broadcast-strategy"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">broadcast strategy</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#random-strategy"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">random strategy</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Task-Slot"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">Task Slot</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Operator-Chain"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Operator Chain</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E5%9B%9B%E5%B1%82%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">四层运行模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Flink%E4%BB%BB%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">Flink任务分布式运行流程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TaskManager"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">TaskManager</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#JobManager"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">JobManager</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">运行流程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9CAPI"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">基础操作API</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#source"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">source</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#transformation"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">transformation</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#sink"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">sink</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#state"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">state</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Keyed-State"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Keyed State</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#operator-State"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">operator State</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-state"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">自定义 state</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#State-backend"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">State backend</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#MemoryStateBackend"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">MemoryStateBackend</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#FsStateBackend"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">FsStateBackend</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#RocksDBStateBackend"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">RocksDBStateBackend</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#StateBackend%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">StateBackend配置方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%85%A8%E5%B1%80"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">全局</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%B1%80%E9%83%A8"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">局部</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#CheckPoint"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">CheckPoint</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chandy-Lamport-%E7%AE%97%E6%B3%95"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Chandy-Lamport 算法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">重启策略</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%9B%BA%E5%AE%9A%E9%97%B4%E9%9A%94-Fixed-Delay"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">固定间隔(Fixed Delay)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%A4%B1%E8%B4%A5%E7%8E%87-Failure-rate"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">失败率(Failure rate)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E6%97%A0%E9%87%8D%E5%90%AF-No-restart"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">无重启(No restart)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#SavePoint"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">SavePoint</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%92%8Ccheckpoint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">和checkpoint的区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Windows"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">Windows</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#TimeWindows"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">TimeWindows</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Time%E7%A7%8D%E7%B1%BB"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Time种类</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#WaterMark"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">WaterMark</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E6%8D%AE"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">有序数据</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%97%A0%E5%BA%8F%E6%95%B0%E6%8D%AE"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">无序数据</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#QA"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">QA</span></a></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Flink"><span class="toc-number">1.</span> <span class="toc-text">Flink</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number"></span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Flink"><span class="toc-number">1.</span> <span class="toc-text">为什么用Flink</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%89%E7%95%8C%E5%92%8C%E6%97%A0%E7%95%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.</span> <span class="toc-text">处理有界和无界数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E8%8C%83%E5%9B%B4%E5%B9%BF"><span class="toc-number">2.</span> <span class="toc-text">运行范围广</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E4%BB%BB%E6%84%8F%E8%A7%84%E6%A8%A1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">运行任意规模的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%86%85%E5%AD%98%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-number">4.</span> <span class="toc-text">利用内存提升性能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%AD%96%E7%95%A5"><span class="toc-number"></span> <span class="toc-text">数据传输策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#forward-strategy"><span class="toc-number">1.</span> <span class="toc-text">forward strategy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key-based-strategy-key-by"><span class="toc-number">2.</span> <span class="toc-text">key based strategy (key by)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#broadcast-strategy"><span class="toc-number">3.</span> <span class="toc-text">broadcast strategy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#random-strategy"><span class="toc-number">4.</span> <span class="toc-text">random strategy</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Task-Slot"><span class="toc-number"></span> <span class="toc-text">Task Slot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Operator-Chain"><span class="toc-number">1.</span> <span class="toc-text">Operator Chain</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E5%B1%82%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">四层运行模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flink%E4%BB%BB%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">Flink任务分布式运行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskManager"><span class="toc-number">1.</span> <span class="toc-text">TaskManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JobManager"><span class="toc-number">2.</span> <span class="toc-text">JobManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">运行流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9CAPI"><span class="toc-number"></span> <span class="toc-text">基础操作API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#source"><span class="toc-number">1.</span> <span class="toc-text">source</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transformation"><span class="toc-number">2.</span> <span class="toc-text">transformation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sink"><span class="toc-number">3.</span> <span class="toc-text">sink</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#state"><span class="toc-number"></span> <span class="toc-text">state</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Keyed-State"><span class="toc-number">1.</span> <span class="toc-text">Keyed State</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#operator-State"><span class="toc-number">2.</span> <span class="toc-text">operator State</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-state"><span class="toc-number">3.</span> <span class="toc-text">自定义 state</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#State-backend"><span class="toc-number"></span> <span class="toc-text">State backend</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MemoryStateBackend"><span class="toc-number">1.</span> <span class="toc-text">MemoryStateBackend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FsStateBackend"><span class="toc-number">2.</span> <span class="toc-text">FsStateBackend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocksDBStateBackend"><span class="toc-number">3.</span> <span class="toc-text">RocksDBStateBackend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StateBackend%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">StateBackend配置方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80"><span class="toc-number">4.1.</span> <span class="toc-text">全局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8"><span class="toc-number">4.2.</span> <span class="toc-text">局部</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CheckPoint"><span class="toc-number"></span> <span class="toc-text">CheckPoint</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chandy-Lamport-%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">Chandy-Lamport 算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5"><span class="toc-number"></span> <span class="toc-text">重启策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E9%97%B4%E9%9A%94-Fixed-Delay"><span class="toc-number">1.</span> <span class="toc-text">固定间隔(Fixed Delay)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E7%8E%87-Failure-rate"><span class="toc-number">2.</span> <span class="toc-text">失败率(Failure rate)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%90%AF-No-restart"><span class="toc-number">3.</span> <span class="toc-text">无重启(No restart)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SavePoint"><span class="toc-number"></span> <span class="toc-text">SavePoint</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8Ccheckpoint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">和checkpoint的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows"><span class="toc-number"></span> <span class="toc-text">Windows</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TimeWindows"><span class="toc-number">1.</span> <span class="toc-text">TimeWindows</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Time%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">Time种类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WaterMark"><span class="toc-number">2.</span> <span class="toc-text">WaterMark</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">有序数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.</span> <span class="toc-text">无序数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QA"><span class="toc-number"></span> <span class="toc-text">QA</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">Flink相关</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-04-03<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-09-16</time><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apeche Flink 是一个框架和分布式处理引擎，用于在无边界和有边界数据流上进行有状态的计算.Flink能在常见的集群环境中运行，并能以内存数独和任意规模进行计算。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale</span><br></pre></td></tr></tbody></table></figure>
<h2 id="为什么用Flink"><a href="#为什么用Flink" class="headerlink" title="为什么用Flink"></a>为什么用Flink</h2><ol>
<li>MapReduce 核心过程shuffle 会产生大量的IO操作导致性能下降。</li>
<li>Spark 上位。 基于内存处理数据，但是没有对内存进行很好的管理.</li>
<li>Flink 实时很优秀(SparkSteaming虽然是也是流但是本质上还是通过批处理的概念去完成的)、兼容流式处理和离线处理(但是没有spark好用)</li>
</ol>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="处理有界和无界数据"><a href="#处理有界和无界数据" class="headerlink" title="处理有界和无界数据"></a>处理有界和无界数据</h2><p>有界流:<br>无界数据: 有定义流开始，但是没有定义流的结束。它们会无休止的产生数据。无界流的数据必须持续处理，即数据提取后需要立刻处理。我们不能等到所有数据都到达再处理，因为输入是无限的，在任何时候输入都不会完成。处理无界数据通常需要以特定的顺序摄取事件， 例如事件发生的顺序，以便能够推断结果的完整性。<br>像商场的自动扶梯 一直等待顾客。<br>有界流:<br>有定义流的开始，也有定义流的结束。有界流可以在摄取所有数据后再进行处理计算，有界流所有数据可以被排序，所以不需要有序摄取。有界流处理通常被成为批处理<br>像电梯 客人按下电梯 进入电梯 关门 运行电梯  </p>
<h2 id="运行范围广"><a href="#运行范围广" class="headerlink" title="运行范围广"></a>运行范围广</h2><p>YARN、Mesos、Kubernetes</p>
<h2 id="运行任意规模的应用"><a href="#运行任意规模的应用" class="headerlink" title="运行任意规模的应用"></a>运行任意规模的应用</h2><p>处理数据量大，节点规模上限大</p>
<h2 id="利用内存提升性能"><a href="#利用内存提升性能" class="headerlink" title="利用内存提升性能"></a>利用内存提升性能</h2><p>有状态的Flink程序对本地状态访问进行了优化。任务的状态始终保留在内存中，如果状态大小超过可用内存，则会保存在能高效访问的磁盘数据结构中。任务通过本地(通常在内存中)状态进行所有的计算，从而产生非常低的数据言辞。Flink通过定期和一步对本地状态持久化来保证故障场景下精确一次的状态一致性。</p>
<h1 id="数据传输策略"><a href="#数据传输策略" class="headerlink" title="数据传输策略"></a>数据传输策略</h1><p>在一个dataFlow中会出现多种策略</p>
<h2 id="forward-strategy"><a href="#forward-strategy" class="headerlink" title="forward strategy"></a>forward strategy</h2><p>发送策略</p>
<ol>
<li>一个 task 的输出只发送给一个 task 作为输入</li>
<li>如果两个 task 都在一个 JVM 中的话，那么就可以避免网络开销</li>
</ol>
<h2 id="key-based-strategy-key-by"><a href="#key-based-strategy-key-by" class="headerlink" title="key based strategy (key by)"></a>key based strategy (key by)</h2><p>按key分组策略（Spark的宽依赖）  </p>
<ol>
<li>数据需要按照某个属性(我们称为 key)进行分组(或者说分区)</li>
<li>相同 key 的数据需要传输给同一个 task，在一个 task 中进行处理</li>
</ol>
<h2 id="broadcast-strategy"><a href="#broadcast-strategy" class="headerlink" title="broadcast strategy"></a>broadcast strategy</h2><p>广播策略  </p>
<ol>
<li>上游task的输出会发送到下游所有的task作为输入</li>
</ol>
<h2 id="random-strategy"><a href="#random-strategy" class="headerlink" title="random strategy"></a>random strategy</h2><p>随机策略  </p>
<ol>
<li>数据随机的从一个 task 中传输给下一个 operator 所有的 subtask</li>
<li>保证数据能均匀的传输给所有的 subtask</li>
</ol>
<h1 id="Task-Slot"><a href="#Task-Slot" class="headerlink" title="Task Slot"></a>Task Slot</h1><h2 id="Operator-Chain"><a href="#Operator-Chain" class="headerlink" title="Operator Chain"></a>Operator Chain</h2><p>算子链<br>为了更高效地分布式执行，Flink会尽可能地将operator的subtask链接（chain）在一起形成task。每个task在一个线程中执行。将operators链接成task是非常有效的优化：它能减少线程之间的切换，减少消息的序列化/反序列化，减少数据在缓冲区的交换，减少了延迟的同时提高整体的吞吐量。<br>task合并 将多个task合并成一个task<br>条件  </p>
<ol>
<li>数据传输策略是 forward strategy keyBy、sum、print等操作</li>
<li>在同一个TaskManager中运行</li>
<li>并行度一致 </li>
</ol>
<h1 id="四层运行模型"><a href="#四层运行模型" class="headerlink" title="四层运行模型"></a>四层运行模型</h1><p>一个dataFlow提交到Flink上执行需要经过下面4种阶段</p>
<ol>
<li>Stream Graph<br>我们编写代码的流程写代码的任务流程例如：<br>source -> flatMap -> keyed sum -> sink  </li>
<li>Job Graph<br>对Stream Graph种进行优化，比如说看是否有Opwrator Chain<br>source -> flatMap -> keyed sum + slink  </li>
<li>Execution Graph<br>相对于Job Graph增加了并行度的处理  </li>
<li>Physical Execution Graph （三层模型没有这玩意）  </li>
</ol>
<p><img data-src="/blog/page/flink/flow1.jpg" class="lozad"><br><img data-src="/blog/page/flink/flow2.jpg" class="lozad"><br><img data-src="/blog/page/flink/flow3.jpg" class="lozad">  </p>
<h1 id="Flink任务分布式运行流程"><a href="#Flink任务分布式运行流程" class="headerlink" title="Flink任务分布式运行流程"></a>Flink任务分布式运行流程</h1><p><img data-src="/blog/page/flink/flink_ant.jpg" class="lozad">  </p>
<h2 id="TaskManager"><a href="#TaskManager" class="headerlink" title="TaskManager"></a>TaskManager</h2><p>从节点，任务(Task)运行于此<br>TaskManager之间的数据传输通过Netty<br>TaskSlot封装内存网络等资源  </p>
<h2 id="JobManager"><a href="#JobManager" class="headerlink" title="JobManager"></a>JobManager</h2><p>主节点<br>与TaskManager通过Akka方式通信(正在往netty升级)</p>
<h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>代码(Program Code)提交到Flink环境执行flink run后构建为 Stream Graph -> 优化为Job Graph(以上两步称为 Optimizer/Gpaph Builder) -> Submit Job到JobManager -> 加入并行度后变成 Execution Graph -> 通过Scheduler将任务分发调度到Task -> 任务运行中TaskManager将Task Status, Heartbeats,Statistics发送给JobManager</p>
<h1 id="基础操作API"><a href="#基础操作API" class="headerlink" title="基础操作API"></a>基础操作API</h1><h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>输入数据<br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/base/WordCountFlinkForCollection.java">readTextFile()</a> 读取文本文件<br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/base/WordCountFlinkForSocket.java">socketTextStream()</a>  从socket中读取数据<br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/base/WordCountFlinkForCollection.java">fromCollection()</a> 从集合中读取数据<br>addSource() 读取第三方数据源(例如<a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/base/WordCountFlinkForKafka.java">kafka</a>、<a href>自定义数据源</a>))  </p>
<h2 id="transformation"><a href="#transformation" class="headerlink" title="transformation"></a>transformation</h2><p>数据处理  </p>
<ol>
<li><p>map<br>对数据值进行处理<br>场景：将数据补齐 1234-> order:1234<br>和flatMap的区别。map是数据原数据值进行处理，无法改变流你没办法在流中删除某个数据不让他发送到下游。 flatMap可以改变流内容  </p>
</li>
<li><p>filter<br>对数据元进行过滤，true表示放行;false表示过滤<br>场景：过滤异常数据  </p>
</li>
<li><p>union<br>合并多个输入流(合并的流类型必须一致)<br>场景：需要处理N个不同日志数据  </p>
</li>
<li><p>connect<br>链接两个流并且连个流数据类型可不一致  </p>
</li>
<li><p>splic&select<br>更具规则将数据切分为多个流，然后通过select获取指定流<br>场景：订单日志不同类型的订单不同处理  </p>
</li>
</ol>
<h2 id="sink"><a href="#sink" class="headerlink" title="sink"></a>sink</h2><p>输出数据  </p>
<ol>
<li>print() / printToErr()  </li>
<li>writeAsText()  </li>
<li>addSink()  </li>
</ol>
<h1 id="state"><a href="#state" class="headerlink" title="state"></a>state</h1><p>指具体的task/operator的状态。state可以被记录(数据的中间接过)，失败下可以的情况下可以被恢复.<br>按状态区分为:<br>托管状态：由Flink框架管理的状态。 常用<br>原始状态：由用户自行管理状态具体的数据结构, 框架在checkpoint的时候，使用byte[]来读写内容，对其内部数据结构一无所知。通常在DataStream上的状态推荐用托管的状态，当实现一个用户自定义的operator时，会使用到原始状态。不常用  </p>
<h2 id="Keyed-State"><a href="#Keyed-State" class="headerlink" title="Keyed State"></a>Keyed State</h2><p>经过keyBy算子计算的 (常用)<br>经过keyBy计算后每个task中包含多个state，也就是每个key对应一个state</p>
<p>托管状态：<br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/state/map/CountWindowAverageWithValueState.java">ValueState</a><br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/state/map/CountWindowAverageWithListState.java">ListState</a><br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/state/map/CountWindowAverageWithMapState.java">MapState</a><br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/state/map/SumWithReducingState.java">ReducingState</a><br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/state/map/ContainsValueWithAggregatingState.java">AddregatingState</a>  </p>
<h2 id="operator-State"><a href="#operator-State" class="headerlink" title="operator State"></a>operator State</h2><p>未经过keyBy算子计算的 （不常用）<br>state是task级别的state，也就是每个task对应一个state  </p>
<h2 id="自定义-state"><a href="#自定义-state" class="headerlink" title="自定义 state"></a>自定义 state</h2><h1 id="State-backend"><a href="#State-backend" class="headerlink" title="State backend"></a>State backend</h1><p>确定state保存位置  </p>
<h2 id="MemoryStateBackend"><a href="#MemoryStateBackend" class="headerlink" title="MemoryStateBackend"></a>MemoryStateBackend</h2><p>默认方式<br>状态信息存储在TaskManager 的堆内存中，checkpoint 的时候将状态保存到jobManager的堆内存中<br>缺点：<br>只能保存数据量小的状态<br>状态数据可能丢失(因为在内存中)<br>优势：<br>开发测试方便其实就是代码量小了<br>性能高  </p>
<h2 id="FsStateBackend"><a href="#FsStateBackend" class="headerlink" title="FsStateBackend"></a>FsStateBackend</h2><p>用于大部分生产情况(状态大小较小)<br>Fs 可以理解 File System<br>状态信息存储在TaskManager 的堆内存中， checkpoint 的时候将状态保存到指定的文件中(HDFS等文件系统)<br>缺点：<br>状态大小受限于TaskManager内存限制(默认支持5M) 为啥memory 没有这个缺点？<br>优点：<br>状态访问速度快<br>状态信息不会丢失  </p>
<h2 id="RocksDBStateBackend"><a href="#RocksDBStateBackend" class="headerlink" title="RocksDBStateBackend"></a>RocksDBStateBackend</h2><p>用于大部分生产情况(状态大小较大)<br>状态信息存储在RocksDB 数据库，最终保存在本地文件中，checkpoint的时候将状态保存到指定的文件系统中<br>缺点：<br>状态访问速度没有之前的高<br>优点：<br>可以存储超大量的状态信息<br>状态信息不会丢失</p>
<h2 id="StateBackend配置方式"><a href="#StateBackend配置方式" class="headerlink" title="StateBackend配置方式"></a>StateBackend配置方式</h2><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>修改flink-conf.yml<br>(不建议)  </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="局部"><a href="#局部" class="headerlink" title="局部"></a>局部</h3><h1 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h1><p>flink可靠性的保证, 可以保证Flink集群在某个算子因为某些原因出现故障时能将整个应用流图的状态回复到故障之前的某个状态，保证应用流图状态的一致性<br>SparkStream的 checkpoint无法实现仅一次处理<br>任务运行时执行checkpoint将当前的阶段数据及状态记录下来。下次计算是因为宕机或者其他原因某个计算出现异常，flink自动重启获取checkpoint中的数据 继续计算<br>默认只保留最近生成的一个checkpiont, 如需要支持多个修改配置指定checkpoint数量  </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf/flink-conf.yaml</span><br><span class="line"></span><br><span class="line">state.checkpoints.num-retained: 20</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Chandy-Lamport-算法"><a href="#Chandy-Lamport-算法" class="headerlink" title="Chandy-Lamport 算法"></a>Chandy-Lamport 算法</h2><p>类似开会本来要等大家一起开会汇报进度。现在弄了一个在线表格，任务在前的先汇报记录然后流转给下一个任务人(可以等他忙完)然后继续流转。最终到测试汇总然后汇报结束   </p>
<ol>
<li>运行任务 </li>
<li>JobManager 发起CheckPoint<br>JobManager 向任务流中发送 barrier （栅栏）  </li>
<li>source上报CheckPoint<br>source收到barrier 向JobManager上报完成CheckPoint 将source的数据存储(保存位置由设置的StateBackend确定)。并将barrier 通过广播方式发送到下个task  </li>
<li>数据处理<br>在barrier到达task之前的数据按业务继续处理。收到barrier后的数据需要缓存<br>这里有精确一次处理(数据缓存) 和 至少一次处理(不缓存继续发送给下个task)的区别  </li>
<li>barrier对齐<br>在所有的barrier到达后，对task的状态进行checkpoint并将barrier发送到下个task<br>这里如何判断所有的barrier都到了？  </li>
<li>缓存数据处理<br>在所有的barrier到达最后的Sink后，上报JobManager完成checkPoint. 通知存储checkpoint结束  </li>
</ol>
<h1 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h1><p>Flink支持不同的重启策略，以在故障发生时控制作业如何重启，集群在启动时会伴随一个默认的重启策<br>略，在没有定义具体重启策略时会使用该默认策略。 如果在工作提交时指定了一个重启策略，该策略会<br>覆盖集群的默认策略，默认的重启策略可以通过 Flink 的配置文件 flink-conf.yaml 指定。配置参数<br>restart-strategy 定义了哪个策略被使用<br>如果没有启用checkpoint默认不启用重启策略<br>如果启用checkpoint但是没有配置重启策略默认用固定间隔策略。重启次数默认值是：Integer.MAX_VALUE  </p>
<h2 id="固定间隔-Fixed-Delay"><a href="#固定间隔-Fixed-Delay" class="headerlink" title="固定间隔(Fixed Delay)"></a>固定间隔(Fixed Delay)</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一种：全局配置 flink-conf.yaml</span><br><span class="line">restart-strategy: fixed-delay</span><br><span class="line">restart-strategy.fixed-delay.attempts: 3</span><br><span class="line">restart-strategy.fixed-delay.delay: 10 s</span><br><span class="line">第二种：应用代码设置</span><br><span class="line">env.setRestartStrategy(RestartStrategies.fixedDelayRestart(</span><br><span class="line">3, // 尝试重启的次数</span><br><span class="line">Time.of(10, TimeUnit.SECONDS) // 间隔</span><br><span class="line">));</span><br></pre></td></tr></tbody></table></figure>

<h2 id="失败率-Failure-rate"><a href="#失败率-Failure-rate" class="headerlink" title="失败率(Failure rate)"></a>失败率(Failure rate)</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">restart-strategy: failure-rate</span><br><span class="line">restart-strategy.failure-rate.max-failures-per-interval: 3</span><br><span class="line">restart-strategy.failure-rate.failure-rate-interval: 5 min</span><br><span class="line">restart-strategy.failure-rate.delay: 10 s</span><br><span class="line">第二种：应用代码设置</span><br><span class="line">env.setRestartStrategy(RestartStrategies.failureRateRestart(</span><br><span class="line">3, // 一个时间段内的最大失败次数</span><br><span class="line">Time.of(5, TimeUnit.MINUTES), // 衡量失败次数的是时间段</span><br><span class="line">Time.of(10, TimeUnit.SECONDS) // 间隔</span><br><span class="line">));</span><br></pre></td></tr></tbody></table></figure>

<h2 id="无重启-No-restart"><a href="#无重启-No-restart" class="headerlink" title="无重启(No restart)"></a>无重启(No restart)</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一种：全局配置 flink-conf.yaml</span><br><span class="line">restart-strategy: none</span><br><span class="line">第二种：应用代码设置</span><br><span class="line">env.setRestartStrategy(RestartStrategies.noRestart());</span><br></pre></td></tr></tbody></table></figure>

<h1 id="SavePoint"><a href="#SavePoint" class="headerlink" title="SavePoint"></a>SavePoint</h1><p>SavePoint是一个重量级的Checkpoint, 某个时间点上整个程序的状态的全局镜像<br>主要用于程序升级、代码升级、参数修改  </p>
<h2 id="和checkpoint的区别"><a href="#和checkpoint的区别" class="headerlink" title="和checkpoint的区别"></a>和checkpoint的区别</h2><ol>
<li>概念区分<br>Checkpoint-> 自动容错机制;<br>Savepoint-> 程序全局状态镜像;  </li>
<li>功能作用区分<br>Checkpoint-> 是程序自动容错，快速恢复;<br>Savepoint-> 是程序修改后继续从状态恢复，程序升级;   </li>
<li>触发条件区分<br>Checkpoint-> Flink系统行为;<br>Savepoint-> 用户触发;  </li>
<li>状态文件保留区分<br>Checkpoint-> Checkpoint默认程序删除，可以设置CheckpointConfig中的参数进行保留<br>Savepoint-> 会一直保存，除非用户删除  </li>
</ol>
<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="TimeWindows"><a href="#TimeWindows" class="headerlink" title="TimeWindows"></a>TimeWindows</h2><h3 id="Time种类"><a href="#Time种类" class="headerlink" title="Time种类"></a>Time种类</h3><ol>
<li>Event Time<br>事件产生的时间，它通常由事件中的时间戳描述。<br>Flink牛逼的地方  </li>
</ol>
<ol start="2">
<li><p>Ingestion time<br>事件进入Flink的时间(一般不用)  </p>
</li>
<li><p>Processing Time<br>事件被处理时当前系统的时间<br>SparkStream 只有这个时间没有其他时间  </p>
</li>
</ol>
<h2 id="WaterMark"><a href="#WaterMark" class="headerlink" title="WaterMark"></a>WaterMark</h2><p>处理乱序时间(EventTime)<br>通过增加windows的长度(水位)处理一些迟到的事件  </p>
<p>当窗口被触发后，在进来窗口时间段内的事件也不会接收会被抛弃。比如设置窗口截止是00:05 然后进来了 03、04然后进来了06导致窗口触发了这时候在进来04时间的数据也不会被接受; 但是可以通过API来补偿处理这些数据(侧输出流)     </p>
<h3 id="有序数据"><a href="#有序数据" class="headerlink" title="有序数据"></a>有序数据</h3><p>数据正常顺序的进来<br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/window/TimeWindowWordCount.java">TimeWindowWordCount</a><br>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(hadoop,2)  // 第15s 的时候 检测到 13s发出的两个hadoop</span><br><span class="line">(hadoop,3)  // 第20s 的时候 检测到 13s发出的两个hadoop + 16s 发出的一个hadoop</span><br><span class="line">(hadoop,1)  // 第25s 的时候 检测到 16s 发出的一个hadoop</span><br></pre></td></tr></tbody></table></figure>

<h3 id="无序数据"><a href="#无序数据" class="headerlink" title="无序数据"></a>无序数据</h3><p>数据乱序的进来<br>正常情况下第 13 秒的时候连续发送 2 个事件，但是有一个事件确实在第13秒的<br>发送出去了，另外一个事件因为某种原因在19秒的时候才发送出去，第 16 秒的时候再发送 1 个事件<br>默认什么都不处理的情况<br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/window/TimeWindowWordCount.java">SumProcessWindowFunction</a><br>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(hadoop,1)  // 第15s 的时候 检测到 13s发出的一个hadoop</span><br><span class="line">(hadoop,3)  // 第20s 的时候 检测到 13s发出的一个hadoop + 16s 发出的一个hadoop + 19s 发出的原本在13s就应该发出的一个hadoop</span><br><span class="line">(hadoop,2)  // 第25s 的时候 检测到 16s 发出的一个hadoop + 19s 发出的原本在13s就应该发出的一个hadoop</span><br></pre></td></tr></tbody></table></figure>
<p>通过EventTime处理无序数据<br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/window/TimeWindowWordCountEventTime.java">TimeWindowWordCountEventTime</a><br>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(hadoop,1)  // 第15s 的时候 检测到 13s发出的一个hadoop</span><br><span class="line">(hadoop,3)  // 第20s 的时候 检测到 13s发出的一个hadoop + 16s 发出的一个hadoop + 19s 发出的原本在13s就应该发出的一个hadoop</span><br><span class="line">(hadoop,1)  // 第25s 的时候 检测到 16s 发出的一个hadoop</span><br></pre></td></tr></tbody></table></figure>
<p>输出时间   </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前窗口时间: 17:56:10</span><br><span class="line">窗口处理时间: 17:56:10</span><br><span class="line">窗口开始时间: 17:55:55</span><br><span class="line">窗口结束时间: 17:56:05</span><br></pre></td></tr></tbody></table></figure>
<p>第25s的时候收到第13s的数据已经过滤了。 但是13s的时候没有收到。 因为窗口在15s的时候事件还没发出等到发出的时候已经进入到另外的window了<br>通过增加WaterMark 处理乱序<br><a target="_blank" rel="noopener" href="https://github.com/sovwcwsfm/HadoopLearn/blob/master/flink/src/main/java/net/fibonacci/flink/window/TimeWindowWordCountWaterMark.java">TimeWindowWordCountWaterMark</a><br>输出  </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(hadoop,2)  // 第15s 的时候 检测到 13s发出的一个hadoop + 通过增加水位 在19s发出的原本在13s就应该发出的一个hadoop</span><br><span class="line">(hadoop,3)  // 第20s 的时候 检测到 13s发出的两个hadoop + 16s 发出的一个hadoop</span><br><span class="line">(hadoop,1)  // 第25s 的时候 检测到 16s 发出的一个hadoop</span><br></pre></td></tr></tbody></table></figure>
<p>输出时间   </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前窗口时间: 17:56:10</span><br><span class="line">窗口处理时间: 17:56:10</span><br><span class="line">窗口开始时间: 17:55:55</span><br><span class="line">窗口结束时间: 17:56:05</span><br></pre></td></tr></tbody></table></figure>
<p>窗口的总长没有发生变化 变化的是窗口的处理时间 延迟了5s  </p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><ol>
<li><p>在做 ProcessWindowFunction 练习wordCount的时候。由于没有用Tuple2用了自定义的对象。然后keyBy直接用的<code>keyBy("fieId")</code>案例里面用的是Tuple2然后keyBy用的是lambda获取的。在实现ProcessWindowFunction的时候就按照样例里面KEY的类型是String</p>
 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class SumProcessWindowFunction extends ProcessWindowFunction<WordCountModel, WordCountModel, String, TimeWindow></span><br></pre></td></tr></tbody></table></figure>
<p> 但是这样在<code>.process(new SumProcessWindowFunction())</code>的时候出现了error告知我KEY的类型应该要用Tuple。对照了很多遍没发现问题，也没觉得是keyBy的问题。按照提示换成Tuple</p>
 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class SumProcessWindowFunction extends ProcessWindowFunction<WordCountModel, WordCountModel, Tuple, TimeWindow></span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">out.collect(new WordCountModel(keyTuple.getField(0), count));</span><br></pre></td></tr></tbody></table></figure>
<p> 这样确实也能玩但是总感觉很怪异。 后面对了一下flink版本发现样例用的是1.12的版本。升级后Key类型设定为String 还是报错。 但是<code>keyBy("fieId")</code>出现了启用的warning。换成lambda获取后正常无报错</p>
 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyBy(WordCountModel::getWord)</span><br></pre></td></tr></tbody></table></figure>

 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class KeyedStream<T, KEY> extends DataStream<T></span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public KeyedStream<T, Tuple> keyBy(String... fields) {</span><br><span class="line">    return this.keyBy((Keys)(new ExpressionKeys(fields, this.getType())));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public <K> KeyedStream<T, K> keyBy(KeySelector<T, K> key) {</span><br><span class="line">    Preconditions.checkNotNull(key);</span><br><span class="line">    return new KeyedStream(this, (KeySelector)this.clean(key));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 查看源码可以发现KeyedStream的两个泛型第二个是KEY的类型<br> 两个keyBy 通过field作为入参的强制使用的Tuple, 通过KeySelector使用了lambda的  </p>
</li>
<li><p>EventTime 是事件驱动的时间，但是案例里面其实就是日志里面的一个字段数据。为什么这里说牛逼？  </p>
</li>
<li><p>滑动窗口时间分段的问题<br> 如果按照窗口大小10s 滑动时间5s的话Flink划分的窗口就是</p>
 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[00:00:00, 00:00:05) [00:00:05, 00:00:10)</span><br><span class="line">[00:00:10, 00:00:15) [00:00:15, 00:00:20)</span><br><span class="line">[00:00:20, 00:00:25) [00:00:25, 00:00:30)</span><br><span class="line">[00:00:30, 00:00:35) [00:00:35, 00:00:40)</span><br><span class="line">[00:00:40, 00:00:45) [00:00:45, 00:00:50)</span><br><span class="line">[00:00:50, 00:00:55) [00:00:55, 00:01:00)</span><br><span class="line">[00:01:00, 00:01:05) ...</span><br></pre></td></tr></tbody></table></figure>
<p> 如果你在00:00:02执行的程序。触发的时间还是在00:00:05而不是00:00:08。</p>
 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.window(SlidingProcessingTimeWindows.of(Time.seconds(11), Time.seconds(7)))</span><br></pre></td></tr></tbody></table></figure>
<p> 如上代码所示，窗口为11s, 滑动时间为7s 都是60无法乘除的，时间分段是怎么分的起始时间怎么来的？<br> 查看源码  </p>
 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.flink.streaming.api.windowing.assigners;</span><br><span class="line"></span><br><span class="line">public class SlidingProcessingTimeWindows extends WindowAssigner<Object, TimeWindow> {</span><br><span class="line">    ......</span><br><span class="line">    @Override</span><br><span class="line">    public Collection<TimeWindow> assignWindows(Object element, long timestamp, WindowAssignerContext context) {</span><br><span class="line">        timestamp = context.getCurrentProcessingTime();</span><br><span class="line">        List<TimeWindow> windows = new ArrayList<>((int) (size / slide));</span><br><span class="line">        long lastStart = TimeWindow.getWindowStartWithOffset(timestamp, offset, slide);</span><br><span class="line">        for (long start = lastStart;</span><br><span class="line">            start > timestamp - size;</span><br><span class="line">            start -= slide) {</span><br><span class="line">            windows.add(new TimeWindow(start, start + size));</span><br><span class="line">        }</span><br><span class="line">        return windows;</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">package org.apache.flink.streaming.api.windowing.windows;</span><br><span class="line">public class TimeWindow extends Window {</span><br><span class="line">    // Method to get the window start for a timestamp.</span><br><span class="line">    public static long getWindowStartWithOffset(long timestamp, long offset, long windowSize) {</span><br><span class="line">        return timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> SlidingProcessingTimeWindows中实现了WindowAssigner接口的assignWindows方法。里面计算得到了lastStart, 这里 timestamp获取了当前程序的运行时间 timestamp - (timestamp - offset + windowSize) % windowSize 取了比timestamp小的最近的一个能被windowSize整除的时间戳<br> <code>new TimeWindow(start, start + size)</code> 窗口和窗口的时间间距就是slide 窗口的长度也就是size <code>List<TimeWindow> windows</code>的长度也就是size/slide<br> 比如说程序时间是 1589681103000(2020-05-17 10:05:03) 那windows中的数据就是</p>
 <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TimeWindow{start=1589681100000, end=1589681700000};</span><br><span class="line">TimeWindow{start=1589681095000, end=1589681695000};</span><br><span class="line">TimeWindow{start=1589681090000, end=1589681690000}</span><br><span class="line">......</span><br><span class="line">TimeWindow{start=1589680505000, end=1589681105000}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>test<br>flink结果导出到es通过kibana展示</p>
</li>
<li><p>案例<br>每隔5分钟统计最近1小时的热门商品（这里定top5）<br>需求拆解：<br>滑动窗口 长度 3600s；滑动时间 5min<br>计算窗口内的Top5  </p>
</li>
</ol>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Fibonacci</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://sovwcwsfm.com/blog/page/flink.html">http://sovwcwsfm.com/blog/page/flink.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sovwcwsfm.com">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据    </a><a class="post-meta__tags" href="/tags/Flink/">Flink    </a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/blog/page/MySQL20210615.html"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>MySQL</span></div></a></div><div class="next-post pull-right"><a href="/blog/page/flume.html"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Flume相关</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/blog/page/flume.html" title="Flume相关"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Flume相关</div></a></div><div class="relatedPosts_item"><a href="/blog/page/hbase.html" title="HBase相关"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">HBase相关</div></a></div><div class="relatedPosts_item"><a href="/blog/page/hive.html" title="Hive相关"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Hive相关</div></a></div><div class="relatedPosts_item"><a href="/blog/page/spark.html" title="Spark相关"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Spark相关</div></a></div><div class="relatedPosts_item"><a href="/blog/page/kafka.html" title="Kafka相关"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Kafka相关</div></a></div><div class="relatedPosts_item"><a href="/blog/page/datawarehouse.html" title="数仓相关"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">数仓相关</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2021 By Fibonacci</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>